// Generated by CoffeeScript 1.4.0
(function() {
  var app, browser, browserEnabled, browsersEnabledByDefault, bundle, crypto, enabledBrowsers, fs, knownBrowsers, path, reqToBrowser, sizeCheck, useragent, useragentFamilyToBrowser, _i, _len,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app = __meteor_bootstrap__.app;

  bundle = __meteor_bootstrap__.bundle;

  crypto = __meteor_bootstrap__.require('crypto');

  fs = __meteor_bootstrap__.require('fs');

  path = __meteor_bootstrap__.require('path');

  useragent = __meteor_bootstrap__.require('useragent');

  knownBrowsers = ['android', 'chrome', 'firefox', 'IE', 'mobileSafari', 'opera', 'safari'];

  browsersEnabledByDefault = ['android', 'IE', 'mobileSafari', 'opera', 'safari'];

  enabledBrowsers = {};

  for (_i = 0, _len = browsersEnabledByDefault.length; _i < _len; _i++) {
    browser = browsersEnabledByDefault[_i];
    enabledBrowsers[browser] = true;
  }

  useragentFamilyToBrowser = {
    'Android': 'android',
    'Chrome': 'chrome',
    'Firefox': 'firefox',
    'IE': 'IE',
    'Mobile Safari': 'mobileSafari',
    'Opera': 'opera',
    'Safari': 'safari'
  };

  Meteor.AppCache = {
    config: function(options) {
      var option, value, _j, _len1;
      for (option in options) {
        value = options[option];
        if (option === 'browsers') {
          enabledBrowsers = {};
          for (_j = 0, _len1 = value.length; _j < _len1; _j++) {
            browser = value[_j];
            enabledBrowsers[browser] = true;
          }
        } else if (__indexOf.call(knownBrowsers, option) >= 0) {
          enabledBrowsers[option] = value;
        } else {
          throw new Error('Unknown AppCache config option: ' + option);
        }
      }
      return void 0;
    }
  };

  reqToBrowser = function(req) {
    return useragentFamilyToBrowser[useragent.lookup(req.headers['user-agent']).family];
  };

  browserEnabled = function(req) {
    return enabledBrowsers[reqToBrowser(req)];
  };

  Meteor._app_cache_manifest_hook = function(req) {
    if (browserEnabled(req)) {
      return 'manifest="/app.manifest"';
    } else {
      return '';
    }
  };

  app.use(function(req, res, next) {
    var body, digest, hash, manifest, resource, urlPrefix, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
    if (req.url !== '/app.manifest') {
      return next();
    }
    if (!browserEnabled(req)) {
      res.writeHead(404);
      res.end();
      return;
    }
    hash = crypto.createHash('sha1');
    hash.update(JSON.stringify(__meteor_runtime_config__), 'utf8');
    hash.update(fs.readFileSync(path.join(bundle.root, 'app.html')));
    _ref = bundle.manifest;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      resource = _ref[_j];
      if (resource.where === 'client') {
        hash.update(resource.hash);
      }
    }
    digest = hash.digest('hex');
    manifest = "CACHE MANIFEST\n\n";
    manifest += '# ' + digest + "\n\n";
    manifest += "CACHE:" + "\n";
    manifest += "/" + "\n";
    _ref1 = bundle.manifest;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      resource = _ref1[_k];
      if (resource.where === 'client') {
        manifest += resource.url + "\n";
      }
    }
    manifest += "\n";
    manifest += "FALLBACK:\n";
    _ref2 = Meteor._routePolicy.urlPrefixesFor('app');
    for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
      urlPrefix = _ref2[_l];
      manifest += urlPrefix + " /" + "\n";
    }
    manifest += "\n";
    manifest += "NETWORK:\n";
    _ref3 = Meteor._routePolicy.urlPrefixesFor('network');
    for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
      urlPrefix = _ref3[_m];
      manifest += urlPrefix + "\n";
    }
    body = new Buffer(manifest);
    res.setHeader('Content-Type', 'text/cache-manifest');
    res.setHeader('Content-Length', body.length);
    return res.end(body);
  });

  sizeCheck = function() {
    var resource, totalSize, _j, _len1, _ref;
    totalSize = 0;
    _ref = bundle.manifest;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      resource = _ref[_j];
      if (resource.where === 'client') {
        totalSize += resource.size;
      }
    }
    if (totalSize > 5 * 1024 * 1024) {
      return Meteor._debug("** You are publishing " + totalSize + " bytes of assets (including\n" + "** the contents of the public/ directory) to be stored in the\n" + "** browser's application cache.\n" + "**\n" + "** Browsers differ in the amount of data they will store in the app\n" + "** cache, and if you go over their limit they don't gracefully fallback to\n" + "** just running the app online (going over their limit breaks the app online\n" + "** as well as making it not cacheable for offline use).\n" + "**\n" + "** To avoid this problem we recommend keeping the size of your static\n" + "** application assets under 5MB.");
    }
  };

  sizeCheck();

}).call(this);
